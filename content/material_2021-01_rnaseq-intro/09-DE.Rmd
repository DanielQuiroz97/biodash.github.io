---
title: "Differential expression (DE) analysis <br> with DESeq2"
author: "Jelmer Poelstra"
date: "3/26/2021"
output:
  html_document:
    code_download: true
    toc_depth: 3
    toc: true
    toc_float: true
    theme: cerulean
    highlight: tango
    anchor_sections: true
    css: html_page.css
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo=TRUE, eval=TRUE, cache=TRUE,
  warning=FALSE, message=FALSE,
  class.source = 'r_code',
  class.output = 'r_output',
  class.warning = 'r_warning',
  class.message = 'r_warning',
  class.error = 'r_error'
  )
```

<br> <br>

----

## Getting set up

### Start an RStudio session

- Login to OSC at <https://ondemand.osc.edu>.

- Click on `Interactive Apps` (top bar) > `RStudio Server (Owens and Pitzer)`

<p align="center">
<img src=img/apps.png width="500">
</p>

- Fill out the form as shown [here](slides/03-OSC-slides.html#rstudio_server_job).

- Now, you should see a box like this:

<p align="center">
<img src=img/osc_queued.png width="700">
</p>

- Your job should start running pretty soon, and when it's ready the box should look like this: 

<p align="center">
<img src=img/osc_running.png width="700">
</p>

- Click `Connect to RStudio Server` at the bottom of the box, and an RStudio Server instance will open. You're ready to go!

### Create an RStudio Project

```{r, eval=FALSE}
basedir <- '/fs/project/PAS0471/teach/misc/2021-02_rnaseq/'

# Get your user name (by running a shell command via the `system()` function:
me <- system("echo $USER", intern = TRUE)

# Build the path to the target dir:
proj_dir <- file.path(basedir, me)

# Create the Project:
library(usethis)
create_project(path = proj_dir)
```

Now, RStudio will reload with the newly created Project open.

If you get the pop-up below, click `Don't Save` (do this whenever you get that pop-up):

<p align="center">
<img src=img/rdata-popup.png width="350">
</p>


### Copy the files

Go the `Terminal` tab next to the R `Console` in the bottom left of the RStudio
window:

```{sh, eval=FALSE}
cd /fs/project/PAS0471/teach/misc/2021-02_rnaseq/$USER

cp ../master/data/meta/metadata.txt data/meta
cp ../master/results/count/gene_counts_all.txt results/count
```

### Load the necessary packages

```{r, warning=FALSE, message=FALSE}
library(DESeq2)        # Differential expression analysis
library(tidyverse)     # Misc. data manipulation and plotting
library(here)          # Managing file paths
library(pheatmap)      # Heatmap plot

theme_set(theme_bw())  # Set ggplot theme
```

### Input and output dirs and files

```{r, eval=TRUE, echo=FALSE}
count_table_file <- "results/count/gene_counts_all.txt"
metadata_file <- "data/meta/metadata.txt"

outdir <- "results/DE/"
plotdir <- "results/DE/fig/"
```

Input files:

- Gene counts table,
  which is the file exactly as it was written by *featureCounts*.
  
- Metadata table, so we can group our samples and make comparisons between
  these groups.

```{r, eval=FALSE}
count_table_file <- here("results/count/gene_counts_all.txt")
metadata_file <- here("data/meta/metadata.txt")
```

Output directories -- and we create them if they don't already exist:

```{r}
outdir <- here("results/DE/")
plotdir <- here("results/DE/fig/")

if (!dir.exists(plotdir)) dir.create(plotdir, recursive = TRUE)
if (!dir.exists(plotdir)) dir.create(plotdir, recursive = TRUE)
```

### Load input data

Load the count table from *featureCounts*:

```{r, eval=TRUE}
raw_counts <- read.table(count_table_file,
                         sep = "\t", header = TRUE, skip = 1)
```

Load the metadata information:

```{r}
metadata <- read.table(metadata_file, header = TRUE)

head(metadata)
```

<br>

----

## Prepare the data

Change the column names, which are very long:

```{r}
colnames(raw_counts)[7:8]
```

```{r}
my_regex <- ".+PonceM_(.+)_V1N.+"
colnames(raw_counts) <- sub(my_regex, "\\1", colnames(raw_counts))

colnames(raw_counts)
```

Remove unnecessary columns with feature metadata:

```{r}
raw_counts[1:5, 1:8]

counts <- raw_counts[, 7:ncol(raw_counts)]
rownames(counts) <- raw_counts$Geneid
```

### Replicate samples

In this table, there are two separate entries for each sample:
each library was sequenced on two lanes.
Recall that in our workflow, we had merged these FASTQ files prior to mapping,
but here we are using the table based on the full dataset produced by Matthew.

So, we will go ahead and merge replicates now, by simply summing the counts:

```{r}
counts.t <- t(counts)
rownames(counts.t) <- names(raw_counts)[7:36]
sums <- rowsum(counts.t, group = rownames(counts.t))
counts <- t(sums)
```

(Alternatively, one could use the specialized function
`DESeq2::collapseReplicates()` for this.)

### Check sample IDs

We will load both the count table and the metadata into *DESeq2*.
When doing so, *DESeq2* assumes that sample IDs in both tables match and 
are provided in the same order. Let's make sure this is indeed the case.

Sort both alphabetically:

```{r}
metadata <- metadata[order(metadata$SampleID), ]
counts <- counts[, order(colnames(counts))]
```

Check if names are the same:

```{r}
metadata$SampleID

colnames(counts)

matching_names <- identical(metadata$SampleID, colnames(counts))
if(matching_names == FALSE) stop("Sample ID in metadata and count matrix do not match!")
```

### Create the DESeq2 object

We will create the DESeq2 object using the function `DESeqDataSetFromMatrix()`,
which we will provide with three pieces of information:

- The count data (argument `countData`)
- The metadata (argument `colData`)
- The model design for the DE analysis (argument `design`):
  for now we specify `~1`, which means "no design" --
  we will change this before the actual DE analysis.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = metadata,
                              design = ~ 1)
```

<br>

----

## Explore the count data

What are dimensions of the count matrix?

```{r}
dim(counts)
```

How many genes (rows) with non-zero counts??

```{r}
dim(counts[rowSums(counts) > 0, ])

```

How many genes with total counts of at least 10?

```{r}
dim(counts[rowSums(counts) >= 10, ])
```

Let's plot a histogram of gene counts:

```{r}
summed_gene_counts <- data.frame(gene_count = rowSums(counts)) %>%
  rownames_to_column('gene_id')

ggplot(data = summed_gene_counts) +
  geom_histogram(aes(x = gene_count), binwidth = 10000) +
  scale_y_log10(expand = c(0, 0)) +
  scale_x_continuous(expand = c(0,0))
```
```{r}
ggplot(data = summed_gene_counts) +
  geom_histogram(aes(x = gene_count), binwidth = 1000) +
  scale_y_log10(expand = c(0, 0)) +
  scale_x_continuous(limits = c(0, 200000), expand = c(0,0)) +
  theme(plot.margin = margin(0.5, 0.7, 0.5, 0.5, "cm"))
```

How are counts distributed across samples?

```{r}
apply(counts, 2, sum)
```

<br>

----

## Principal Component Analysis (PCA) 

### Run the PCA and prepare for plotting

First, we normalize the count data to have even sampling across samples
(with respect to library size) and approximately even variance:

```{r}
vsd <- varianceStabilizingTransformation(dds, blind = TRUE)
```

Next, we run the PCA and retrieve the data to plot with *ggplot2*:

```{r}
pcaData <- plotPCA(vsd,
                   ntop = 500,
                   intgroup = c("AMF", "Treatment"),
                   returnData = TRUE)
```

We extract the percentage of variance explained by different principal components,
so we can later add this information to the plot:

```{r}
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

We create a plot title with some italic text using the `expression()` function: 

```{r}
plot_title <-
  expression("PCA of " * italic(Glycine ~ max) * " transcript count data")
```

### First plot -- with points/icons for each sample

```{r}
pca_plot1 <- ggplot(pcaData,
                    aes(PC1, PC2, color = AMF, shape = Treatment)) +
  geom_point(size = 6) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  ggtitle(plot_title)

print(pca_plot1)
```

### Second plot -- with sample names

```{r}
pca_plot2 <- ggplot(pcaData,
              aes(PC1, PC2, color = AMF, shape = Treatment)) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  geom_text(aes(label = name)) +
  ggtitle(plot_title)

print(pca_plot2)
```

<br>

----

## DE analysis -- full dataset

My design has two factors.
Rather than fit a multivariate model, I decided to merger these to a single factor
(called 'group') and fit a univariate model with this factor.

```{r, eval=FALSE}
dds$group <- factor(paste(dds$AMF, dds$Treatment, sep = "_"))
```

Setting reference to the double negative control (empty substrate, no Agrobacteria).

```{r, eval=FALSE}
dds$group <- relevel(dds$group, ref = "control_mock")
```

Set the analysis design:

```{r, eval=FALSE}
design(dds) <- formula( ~ group)
```

Perform the differential expression analysis:

```{r, eval=FALSE}
dds <- DESeq(dds)
```

The `DESeq()` function above performs three steps consecutively,
which could also be called separately
(as could be useful if wanting to change defaults):
  
  - `estimateSizeFactors()` -- "Normalization" by library size.
    *DESeq2* doesnâ€™t actually normalize the counts,
    it uses raw counts and includes the size factors in the modeling. 
  
  - `estimateDispersions()` -- Estimate gene-wise dispersion.
  
  - `nbinomWaldTest(ddsObj)` -- Fit negative Binomial GLM and calculate
    Wald statistics.

### Adjusted p-values set to `NA`

Some values in the results table can be set to NA for one of the following reasons:

- If within a row, all samples have zero counts,
  the `baseMean` column will be zero, and the log2 fold change estimates,
  p-value and adjusted p-value will all be set to `NA`.

- If a row contains a sample with an extreme count outlier,
  then the p-value and adjusted p-value will be set to `NA`.
  These outlier counts are detected by Cookâ€™s distance.

- If a row is filtered by automatic independent filtering,
  for having a low mean normalized count,
  then only the adjusted p-value will be set to `NA`.

```{r, eval=FALSE}
resultsNames(dds)
```

<br>

----

## DE analysis -- contrast two groups

```{r, eval=FALSE}
my_contrast <- c("Ri_Agrobacterium_myb", "Ri_Agrobacterium_noexp")
```

```{r, eval=FALSE}
res <- results(dds,
               contrast = c("group", my_contrast))
```

- How many adjusted p-values were less than 0.1?

```{r, eval=FALSE}
sum(res$padj < 0.1, na.rm = TRUE)
```

<br>

----

## Exploring the results

### MA-plot:

```{r, eval=FALSE}
plotMA(res, ylim = c(-2, 2))
```

```{r, echo=FALSE}
# May also want to do this after shrinkage
# resLFC <- lfcShrink(dds, coef="condition_treated_vs_untreated", type="apeglm")
```

### Plot specific genes:

```{r, eval=FALSE}
d <- plotCounts(dds,
                gene = which.min(res$padj),
                intgroup = "group",
                returnData = TRUE)

p <- ggplot(d, aes(x = group, y = count)) +
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_log10(breaks = c(25, 100, 400))

```

### Heatmap:

```{r, eval=FALSE}
ntd <- normTransform(dds)
select <- order(rowMeans(counts(dds, normalized = TRUE)),
                decreasing = TRUE)[1:20]
ntd_sel <- assay(ntd)[select, ]
df_meta <- as.data.frame(colData(dds)[, c("AMF", "Treatment")])
```

```{r, eval=FALSE}
pheatmap(ntd_sel,
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         show_rownames = FALSE,
         annotation_col = df_meta)
```

### Export the results

TBA

<br>

----

## DE analysis -- with two factors

TBA

```{r, eval=FALSE, echo=FALSE}
design <- as.formula(~ AMF + Treatment)
ddsObj.raw <- DESeqDataSetFromMatrix(countData = counts,
                                     colData = metadata,
                                     design = design)
ddsObj <- DESeq(ddsObj.raw)
```


