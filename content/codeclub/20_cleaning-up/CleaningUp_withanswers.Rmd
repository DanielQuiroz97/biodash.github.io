---
title: "Cleaning Up"
author: "Jessica Cooperstone"
date: "4/25/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Now that we have gone through a mini-series on regular expressions, with the [basics](https://biodash.github.io/codeclub/17_regex/), some [next level helpers](https://biodash.github.io/codeclub/18_regex2/), and [using tidytext to make word clouds](https://biodash.github.io/codeclub/19_wordclouds/), I thought I'd talk today about some applications of this information to cleaning up your data.

To do this, we are going to practice with the [`palmerpenguins`](https://allisonhorst.github.io/palmerpenguins/) dataset, and get back to the [`bakeoff`](https://bakeoff.netlify.app/) for our practice exercises.

## Load libraries

```{r}
library(tidyverse)
library(janitor) # for cleaning up column names

library(palmerpenguins) # for penguins data
library(bakeoff) # for bakeoff data
```

## Variable names

There are many instances where you may have variables names and/or sample names that are messy. For example, variable names that include characters like white spaces, special characters like symbols, or begin with a number are going to give you problems with some R coding. I'll say that you *can* have these non-standard variable names, but occasionally they will give you a big headache and so I'd recommend to just avoid them.

R variable "rules":

-   can contain letters, numbers, underscores (`_`) and periods (`.`)
-   cannot start with a number or underscore
-   shouldn't be a "reserved" word, like if, else, function, TRUE, FALSE etc. (if you want to see them all, execute `?reserved` in your console)

You can read about the [tidyverse style guide](https://style.tidyverse.org/syntax.html) if you want to learn more.

Lets look at the variable names in `penguins_raw`.

```{r}
glimpse(penguins_raw)
```

What you can see is that there are variable names here that don't comply with the "rules" I just indicated. How can that be?! You can see for the variable `Sample Number` that it is surrounded by backticks. This is how R know that this is a variable name.

Okay, so who cares? If you want to call that particular variable, you will have to put it in backticks. For example:

```{r, eval = FALSE}
# this doesn't work
penguins_raw %>%
  select(Sample Number)
```

```{r}
# this works but is clunky
penguins_raw %>%
  select(`Sample Number`)
```

And, this is using `tidyverse` functions - there will be other situations where you will get non-solvable errors because of your variable names.

tl;dr just make your variable names R compliant, there are lots of other harder things you're going to be doing with coding, so just make this easier for yourself.

### Cleaning variable names

You may be thinking now, okay but what happens if someone else gives me data that has unclean variable names?

Don't worry too much, you can easily fix it. My favorite, and the simplest way to do this is using the package `janitor`, and the function [`clean_names()`](https://www.rdocumentation.org/packages/janitor/versions/1.2.0/topics/clean_names). Certainly you could clean your variable names manually, but why? This is really easy.

```{r}
penguins_clean <- clean_names(penguins_raw)

glimpse(penguins_clean)  
```

You can see that `Sample Number` became `sample_number`, `Culmen Length (mm)` became `culmen_length_mm`.

The default is to parse with "snake" case, which would look like snake\_case. You could also set the argument `case` to:

-   `"lower_camel"` or `"small_camel"` to get lowerCamel
-   `"upper_camel"` or `"big_camel"` to get UpperCamel
-   `"screaming_snake"` or `"all_caps"` to get SCREAMING\_SNAKE (stop yelling please)
-   `"lower_upper"` to get lowerUPPER (I don't know why you'd want this)
-   `"upper_lower"` to get UPPERlower (I also don't know why you'd want this)

## Unite character columns

There will be times when you'd like to take a variable, and combine it with another variable. For example, you might want a column called `region_island` which contains a combination of the `region` and `island` that each penguin is from. We can do this with the function [`unite()`](<https://tidyr.tidyverse.org/reference/unite.html>. The function `unite()` allows you to paste together multiple columns to become one column.

The arguments to `unite` work like this:

`unite(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)`

```{r}
penguins_clean_unite <- penguins_clean %>%
  unite(col = "region_island", 
        region:island, # indicate the columns to unite
        remove = FALSE) # don't remove region and island

head(penguins_clean_unite)
```

This is actually a very bad example since there is only one region, but I think you can see how this function is used.

## Separate character columns

There will be times that you have a column that has two variables embedded within it, and you will want to separate or parse the column to become two separate columns. You can do this with the function [`separate()`](https://tidyr.tidyverse.org/reference/separate.html).

The arguments to separate look like this:

`separate(data, col, into, sep = "yourregex", remove = TRUE, extra = "warn", fill = "warn")`

We might want to separate the column `stage` into `age` and `egg_stage`. We can do this with `separate()`.

Let's look at the column `stage`.

```{r}
penguins_clean$stage[1:5]
```

```{r}
penguins_clean_stage <- penguins_clean %>%
  separate(col = stage,
           into = c("age", "egg_stage"),
           sep = ",", # the comma is the separator
           remove = FALSE) 
```

```{r}
penguins_clean_stage %>%
  select(stage, age, egg_stage) %>%
  head()
```

A different type of example:

The column `individual_id` has two parts: the letter N and then a number, and the letter A and then a number. Let's split this column into two columns, one called `id_n` that contains the number after the N, and a second called `id_a` that contains the number after the A.

```{r}
penguins_clean_fixID <- penguins_clean %>%
  separate(col = individual_id,
           into = c("id_n", "id_a"),
           sep = "A", # can also use regex "[A]"
           remove = FALSE) 
```

```{r}
penguins_clean_fixID %>%
  select(individual_id, id_n, id_a) %>%
  head()
```

This worked to separate out the A, but the N is still linked with `id_n`. We can use separate again to remove it. In this case, we don't want to keep the column that will include only Ns, so we will indicate that in the `into` argument, and we set `remote = TRUE` (which actually you can omit because it is the default).

```{r}
penguins_clean_fixID <- penguins_clean_fixID %>%
  separate(col = id_n,
           into = c(NA, "id_n"), # the NA omits the variable
           sep = "N", # can also use regex "[N]"
           remove = TRUE) # optional, since this is the default 
```

```{r}
penguins_clean_fixID %>%
  select(individual_id, id_n, id_a) %>%
  head()
```

## Extract character columns
We can use [`extract()`](https://tidyr.tidyverse.org/reference/extract.html) to set up regular expressions to allow the separation of our variable `species` into exactly what we want.

We will use str_view to figure out a regex that will work for us.
```{r}
# indicate our string
string <- "Adelie Penguin (Pygoscelis adeliae)"
```

```{r}
# to get Adelie Penguin
str_view(string, "[[:alnum:]]+\\s[[:alnum:]]+")
```

* `[[:alnum:]]` gives you anything alphanumeric.  
* the `+` indicates to match alphanumeric at least 1 time
* `\\s` indicates a space

```{r}
# to get Pygoscelis adeliae
str_view(string, "(?<=\\()[[:alnum:]]+\\s[[:alnum:]]+")
```

* `(?<=)` is called the positive lookbehind, and has this general structure `(?<=B)A` which can be read like "find exprssion A which is preceeded by expression B."  In our example, expression B is a parentheses `(`.  But there is some additional complexity here because parentheses have their own meanings in R, so you need to use the `\\` to escape them.  The whole expression for this part of our regex is `(?<=\\()`.
* `[[:alnum:]]` gives you anything alphanumeric.  
* the `+` indicates to match alphanumeric at least 1 time
* `\\s` indicates a space

Ok our regexs work as desired!  Now we can incorporate them into `extract()`.  Here I am using `.*?`  to indicate the separator, as our separator is ` (`.  If you had a simpler separator, this would look simpler.

```{r}
penguins_clean_extract <- penguins_clean %>%
  extract(col = species,
          into = c("common_name", "genus_species"),
          regex = "([[:alnum:]]+\\s[[:alnum:]]+).*?((?<=\\()[[:alnum:]]+\\s[[:alnum:]]+)", 
          remove = FALSE) 
```

```{r}
penguins_clean_extract %>%
  select(species, common_name, genus_species) %>%
  head()
```

Voila! 

## Exercises
### Exercise 1

Using the dataset `bakers`, combine `bakers_last` with `bakers_first` to create a new column `bakers_last_first` which is indicated like this: Lastname, Firstname.
```{r}
head(bakers)

bakers_2 <- bakers %>%
  unite(col = "bakers_last_first",
        c(baker_last, baker_first),
        sep = ", ")

head(bakers)
```

### Exercise 2
Using the dataset `bakers`, convert the column `hometown` to two columns, where whatever comes before the comma is in a column called `city` and whatever comes after is in a column called `locale`.
```{r}
head(bakers)

bakers_hometown <- bakers %>%
  separate(col = hometown,
           into = c("city", "locale"),
           sep = ", ")

head(bakers_hometown)
```

### Exercise 3
Using the dataset `bakers` add a column `nickname` which indicates the bakers nickname, if they have one.
```{r}
baker_full <- bakers$baker_full
str_view_all(baker_full, '(?<=\\").*(?=\\")') 
# note I used single quotes because there were double quotes in the regex

bakers_nickname <- bakers %>%
  extract(col = baker_full,
          into = "nickname",
          regex = '((?<=\\").*(?=\\"))')

bakers_nickname %>%
  arrange(nickname) %>%
  head()
```



### Exercise 4
Using the dataset `challenge_results`, write a regex to find any `signature` that contains chocolate.  Remove all observations that contain `NA` for the `signature`.  
How many of the signature bakes contain chocolate?  What percentage of the total signature bakes (for which we have bake names) does this represent?
```{r}
# select only signatures, drop NAs
signatures <- challenge_results %>%
  select(signature) %>%
  drop_na() 

# check dimensions 
dim(signatures)

# regex for chocolate (or Chocolate, or Chocolatey)
str_count(signatures, "C?c?hocolat") 

# what percent of signatures contain chocolate
(str_count(signatures, "C?c?hocolat")/count(signatures))*100

```

